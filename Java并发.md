## Java并发
### Java并发问题的来源
导致Java并发问题有三个原因
- 可见性：使用缓存导致出现可见性问题
- 原子性：
- 有序性：使用编译优化导致有序性问题
#### 可见性
可见性定义：一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性。
#### 原子性
定义：一个或者多个操作在CPU执行过程中不被中断的特性被称为原子性。
#### 有序性
---
### Java内存模型
为了解决**可见性**和**有序性**问题，需要**按需禁用缓存和编译优化**，JVM提供了相应的方法。
Java内存模型的作用是规范JVM如何提供按需禁用缓存和编译优化的方法，具体是`volatile`，`synchronized`和`final`三个关键字，已经`Happens-Before`规则。
#### Happens-Before原则
Happens-Before原则表达的是：**前一个操作的结果对后续操作是可见的**。
```java
// 以下代码来源于【参考 1】
class VolatileExample {
  int x = 0;
  volatile boolean v = false;
  public void writer() {
    x = 42;
    v = true;
  }
  public void reader() {
    if (v == true) {
      // 这里 x 会是多少呢？
    }
  }
}
```
<center>代码1</center>
接下来以上述代码为例，学习Happens-Before原则
##### 程序的顺序性原则
定义：**在一个线程中，按照程序顺序，前面的操作Happens-Before于后续的任意操作**。
在代码1中，第6行的`x = 42` happens-before于`v = true`。
##### volatile变量规则
定义：**对一个volatile变量的写操作，Happens-Before于后续对这个volatile变量的读操作**
##### 传递性
定义：**如果A Happens-Before B，并且B Happens-Before C，则A Happens-Before C。**
> 结合volatile变量规则和传递性规则，在代码1中，如果线程1调用了方法`writer()`，线程2调用了方法`reader()`，则在第十一行中`x = 42`。原因如下：
>
> 1. 程序的顺序性原则：`x = 42` Happens-Before写变量`v = true`;
> 2. volatile变量规则：对应volatile变量`v`，写变量`v = true` Happens-Before于读变量`v == true`之前。
> 3. 传递性：根据上述两条规则，`x = 42` Happens-Before于`v == true`之前。
##### 管程中锁的规则
定义：**一个锁的解锁Happens-Before于后续对这个锁的加锁**。
在java中，`synchronized`是对管程的实现。
```java
synchronized (this) { // 此处自动加锁
  // x 是共享变量, 初始值 =10
  if (this.x < 12) {
    this.x = 12; 
  }  
} // 此处自动解锁
```
线程A在进入同步代码块后，x变为12，执行完成之后会自动释放锁，线程B进入代码块后，则可以看到x == 12。
##### 线程start()规则
定义：主线程A在启动子线程B之后，子线程B可以看到主线程A在启动子线程B之前的操作。
```java
Thread B = new Thread(()->{
  // 主线程调用 B.start() 之前
  // 所有对共享变量的修改，此处皆可见
  // 此例中，var==77
});
// 此处对共享变量 var 修改
var = 77;
// 主线程启动子线程
B.start();
```
##### 线程join()原则
join()的作用：**join() method suspends the execution of the calling thread until the object called finishes its execution.**
定义：主线程A等待子线程B完成（主线程A通过调用子线程B的join()方法实现），当子线程B完成后（主线程A中join()方法返回），主线程A可以看到子线程B对**共享变量**的操作。
```java
Thread B = new Thread(()->{
  // 此处对共享变量 var 修改
  var = 66;
});
// 例如此处对共享变量修改，
// 则这个修改结果对线程 B 可见
// 主线程启动子线程
B.start();
B.join()
// 子线程所有对共享变量的修改
// 在主线程调用 B.join() 之后皆可见
// 此例中，var==66
```
#### volatile
- [彻底理解volatile](https://juejin.im/post/5ae9b41b518825670b33e6c4)
- [为什么volatile不能保证原子性而Atomic可以？](https://www.cnblogs.com/Mainz/p/3556430.html)
volatile可以解决变量对所有线程的可见性，但是不保证原子性。
### 互斥锁
原子性的源头是**线程切换**，如果在执行指令的时候，一段代码在**同一时刻只有一个线程执行（互斥）**，则可以保证原子性。
为了实现互斥，对需要互斥执行的代码添加**锁**，一段需要互斥执行的代码成为**临界区**。线程在进入临界区时枷锁，如果成功则进入临界区，否则就等待，直到持有锁的线程解锁；持有锁的线程执行完临界区的代码后，执行解锁。
锁和资源有对应关系，实际应用中可能出现锁和资源不对应的问题，难以定位。
![1570845679145](assets/1570845679145.png)
#### synchronized
- [再有人问你synchronized是什么，就把这篇文章发给他](https://www.hollischuang.com/archives/2637)
- [EntrySet和WaitSet](https://www.cnblogs.com/tiancai/p/9371655.html)
锁的使用有四个要点
- 锁
- 锁保护的资源（临界区）
- 加锁动作
- 解锁动作
synchronized有三种用法
- 修饰非静态方法
  ```java
  class X {
    // 修饰非静态方法
    synchronized void foo() {
      // 临界区
    }
  }  
  ```
- 修饰静态方法
  ```java
  class X {
    // 修饰静态方法
    synchronized static void bar() {
      // 临界区
    }
  }  
  ```
- 修饰代码块
  ```java
  // 修饰代码块
  Object obj = new Object()；
  void baz() {
     synchronized(obj) {
        // 临界区
     }
  ```
`synchronized`在java中是默认加上lock()和unlock()操作的。
`synchronized`使用的锁
- 修饰静态方法：锁定的是当前类的Class对象；
- 修饰非静态方法：锁定的是当前实例对象this
##### TODO- 实现原理
#### 死锁
死锁的定义：**一组互相竞争资源的线程互相等待，导致“永久”阻塞的现象**。
死锁发生的条件
1. **互斥**：共享资源X和Y只能被一个线程占用；
2. **占有且等待**：线程T1已经获取共享资源X，在等待共享资源Y的时候，不释放共享资源X；
3. **不可抢占**：其他线程不能强行抢占线程T1占有的资源；
4. **循环等待**：线程T1等待线程T2占有的资源，线程T2等待线程T1占有的资源。
为了解决死锁，需要破坏死锁发生的条件，只要破坏一个条件，则可以解决死锁的问题。
1. 使用锁就是保证互斥，所以条件一“互斥”无法被破坏；
2. 占有且等待：一次性申请所以的资源，则不存在等待；
3. 不可抢占：占有部分资源的线程在进一步申请其他资源时，如果申请不到，则主动释放占有的资源，可以破坏“不可抢占”的条件；
4. 循环等待：通过按序申请资源预防。所谓按序申请，指资源有线性顺序，申请的时候可以先申请资源序号小的，在申请资源序号大的，可以保证申请资源不存在循环。
#### 等待-通知机制
**等待-通知机制**：线程首先获取互斥锁，当线程要求的条件不满足时，释放互斥锁，进入等待状态；当要求的条件满足时，通知等待的线程，重新获取互斥锁。
在java中，使用`synchronized`和`wait()`、`notify()`、`notifyAll()`实现等待-通知机制。
在线程T1进入临界区后，如果某些条件不满足，需要进入等待状态，在调用`wait()`方法后，当前线程T1会进入阻塞状态，进入**互斥锁的等待队列**。线程在进入等待队列的同时，**会释放持有的互斥锁**，其他线程则有机会获得锁进入临界区。
下图中左边的队列被称为Entry Set，右边的队列被称为Wait Set。JVM为每个对象维护Entry Set和Wait Set，其中Entry Set用于存储等待获取对象内部所的的所有进程，   
![1571037798762](assets/1571037798762.png)
当线程的要求满足时，调用**锁对象**的`notify()`和`notifyAll()`方法，通知互斥锁的等待队列中的线程，告诉线程**条件曾经满足过**。被通知线程需要**重新获取互斥锁**，才可以重新进入临界区执行。
> 曾经满足过：`notify()`只能保证在通知时间点，条件是满足的。因为被通知线程的**执行时间点和通知的时间点**基本不重合，当线程执行的时候，条件有可能已经不满足了。
`notify()`是随机的通知等待队列中的一个线程，而`notifyAll()`会通知等待队列中的所有线程。因此最好使用`notifyAll()`。
![1571037811850](assets/1571037811850.png)
##### wait()和sleep()的区别
- `wait()`会释放互斥锁，`sleep()`不会释放互斥锁；
- `wait()`只能在同步块或者同步方法中使用，而`sleep()`可以在任何地方使用；
---
### todo- 管程
---
### 线程的生命周期
#### 通用的线程生命周期
线程生命周期分为5个
- **初始状态**：线程已经被创建，但是不允许分配CPU执行。
  
  > 此状态属于编程语言特有，被创建表示在编程语言层面被创建，在操作系统层面，真正的线程还没有创建。
- **可运行状态**：线程可以分配CPU执行。
  
  > 此状态下，真正的操作系统线程已经被成功创建了，可以分配CPU执行。
- **运行状态**：操作系统将空闲的CPU分配一个可运行状态的线程，被分配到CPU的线程的状态转化成了**运行状态**。
- **休眠状态**：运行状态的线程如果调用阻塞的API（例如以阻塞方式读文件）或者等待某个事件（例如条件变量），线程状态转换成**休眠状态**并释放CPU使用权。
  
  > 休眠状态的线程无法获得CPU使用权，当等待事件或者阻塞事件结束，线程从**休眠状态**转换成**可运行状态**。
- **终止状态**：线程执行完成或者出现异常会进入**终止状态**。
![1571625645403](assets/1571625645403.png)
#### Java线程的生命周期
- NEW（初始化状态）
- RUNNABLE（可运行/运行状态）
- BLOCKED（阻塞状态）
- WAITING（无时限等待）
- TIMED_WAITING（有时限等待）
- TERMINATED（终止状态）
其中BLOCKED，WAITING和TIMED_WAITING状态属于上述提到的**休眠状态**，无法获取CPU使用权。
##### 状态的转换

